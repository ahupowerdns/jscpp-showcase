#include "mongoose.h"#include <iostream>#include <string>#include <sstream>#include <map>#include <boost/format.hpp>#include <boost/property_tree/ptree.hpp>#include <boost/property_tree/json_parser.hpp>#include <boost/algorithm/string/join.hpp>#include <boost/foreach.hpp>#include <boost/variant.hpp>#include <arpa/inet.h>#include <sys/socket.h>#include <netdb.h>#include <ifaddrs.h>#include <boost/variant/recursive_variant.hpp>using namespace std;using namespace boost::property_tree;using namespace boost::property_tree::json_parser;using namespace boost::algorithm;struct jsonmapitem;struct jsonvectoritem;typedef boost::variant<boost::recursive_wrapper<jsonmapitem> , string, boost::recursive_wrapper<jsonvectoritem> > jsonitem_t;struct jsonmapitem{  jsonmapitem(){}  jsonmapitem(const map<string, jsonitem_t>& in) : inner(in){}  map<string, jsonitem_t> inner;};struct jsonvectoritem{  jsonvectoritem(){}  jsonvectoritem(const vector<jsonitem_t>& in) : inner(in){}  vector<jsonitem_t> inner;};class jsonitem_visitor : public boost::static_visitor<ptree>{public:    jsonitem_visitor(ptree& pt) : d_pt(pt) {}        ptree operator()(const std::string & str)    {      cout << "str visitor"<<endl;      d_pt.push_back(make_pair("", str));      return d_pt;    }    ptree operator()(const jsonmapitem& sub)     {      cout << "map visitor"<<endl;            for(map<string, jsonitem_t>::const_iterator iter = sub.inner.begin(); iter != sub.inner.end() ; ++ iter) {        jsonitem_visitor jv(d_pt);        d_pt.push_back(make_pair(iter->first, apply_visitor(jv, iter->second)));      }            return d_pt;    }        ptree operator()(const jsonvectoritem& vec)     {      cout << "vector visitor"<<endl;      ptree vectree;      BOOST_FOREACH(const jsonitem_t& val, vec.inner) {        jsonitem_visitor jv(vectree);        vectree.push_back(make_pair("", apply_visitor(jv, val)));      }      return d_pt;    }private:    ptree& d_pt;    };ptree json2pt(const jsonitem_t& input){  ptree pt;  if(const string* str = boost::get<string>(&input)) {    pt.put("", *str);  }   else if(const jsonmapitem* jmi = boost::get<jsonmapitem>(&input)) {    for(map<string, jsonitem_t>::const_iterator iter = jmi->inner.begin(); iter != jmi->inner.end() ; ++ iter) {      pt.push_back(make_pair(iter->first, json2pt(iter->second)));    }  }  else if(const jsonvectoritem* jvi = boost::get<jsonvectoritem>(&input)) {    for(vector<jsonitem_t>::const_iterator iter = jvi->inner.begin(); iter != jvi->inner.end(); ++iter) {      pt.push_back(make_pair("", json2pt(*iter)));    }  }  return pt;}string pt2string(const jsonitem_t& input){  ptree pt = json2pt(input);  ostringstream str;  write_json(str, pt);  return str.str();}static void *callback(enum mg_event event,                      struct mg_connection *conn) {  const struct mg_request_info *request_info = mg_get_request_info(conn);    if (event != MG_NEW_REQUEST)    return 0;      if(strcmp(request_info->uri, "/interfaces")==0) {    struct ifaddrs *ifaddr, *ifa;    int family, s;    char host[NI_MAXHOST];    if (getifaddrs(&ifaddr) == -1) {      perror("getifaddrs");      exit(EXIT_FAILURE);    }    typedef map<string, vector<jsonitem_t> > interfaces_t;    interfaces_t interfaces;        for (ifa = ifaddr; ifa != NULL; ifa = ifa->ifa_next) {      interfaces[ifa->ifa_name]; // populate      if (ifa->ifa_addr == NULL)        continue;              string address;      family = ifa->ifa_addr->sa_family;            if( family == AF_INET || family == AF_INET6 ) {        s = getnameinfo(ifa->ifa_addr, (family == AF_INET) ? sizeof(struct sockaddr_in) : sizeof(struct sockaddr_in6),                           host, NI_MAXHOST, NULL, 0, NI_NUMERICHOST);        if (s) {           printf("getnameinfo() failed: %s\n", gai_strerror(s));           exit(EXIT_FAILURE);        }        interfaces[ifa->ifa_name].push_back(host);      }      else if(family == AF_PACKET) {        boost::format macfmt("%02x:%02x:%02x:%02x:%02x:%02x");        unsigned char* ptr = (unsigned char*)ifa->ifa_addr;        ptr+=12;                for(int n=0; n < 6; ++n)          macfmt % (int)ptr[n];                  interfaces[ifa->ifa_name].push_back(macfmt.str());      }    }            string resp;    map<string, jsonitem_t> root;    root["hi"]=string("there");        vector<jsonitem_t> intervec;    BOOST_FOREACH(const interfaces_t::value_type& val, interfaces) {      map<string, jsonitem_t> interface;      interface["name"] = val.first;      interface["addresses"] = val.second;      intervec.push_back(interface);    }    root["interfaces"]=intervec;     jsonitem_t jroot = root;        resp=pt2string(jroot);        mg_printf(conn,              "HTTP/1.1 200 OK\r\n"              "Content-Type: text/plain\r\n"              "Content-Length: %ld\r\n"        // Always set Content-Length              "\r\n"              "%s",              resp.length(), resp.c_str());    // Mark as processed    return (void*)"";  } else {    return NULL;  }}int main(){  struct mg_context *ctx;  const char *options[] = {"listening_ports", "8080",                            "document_root", "./html",                            NULL};  ctx = mg_start(&callback, NULL, options);  getchar();  // Wait until user hits "enter"  mg_stop(ctx);  return 0;}